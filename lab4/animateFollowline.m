function animateFollowline(simulation)
% animateFollowline(simulation) creates an animation of a followline robot.
% The input "simulation" represents the data generated by the function 
% simulateFollowline().

t = simulation.time;
x = simulation.x;
y = simulation.y;
psi = simulation.psi;

% To adjust the axes of the plot so we can see the whole simulation
robotSize = 0.075;
minX = min(x) - robotSize;
maxX = max(x) + robotSize;
minY = min(y) - robotSize;
maxY = max(y) + robotSize;
deltaX = maxX - minX;
deltaY = maxY - minY;
axisSize = max(deltaX, deltaY);

dt = 1 / 60;
videoTime = t(1):dt:t(end);
% Interpolates the video so we have an adequate framerate
x = interp1(t, x, videoTime);
y = interp1(t, y, videoTime);
psi = interp1(t, psi, videoTime);

% Creating a blue that does not harm the eye...
% The pure blue 'b' is really bad in a pure black 'k' background...
niceBlue = [0, 0.4470, 0.7410];

close all;
figure('Position', [0, 0, 560 * 2, 420 * 2]);
hold on;
points = computeRobotPoints(x(1), y(1), psi(1));
% Initial drawing of the robot
handleChassis = fill(points.chassis.x, points.chassis.y, 'k');
handleTeamPattern = fill(points.teamPattern.x, points.teamPattern.y, 'r');
handleIdPattern = fill(points.idPattern.x, points.idPattern.y, niceBlue);
axis([minX axisSize minY axisSize]);
axis square;
set(gca, 'nextplot', 'replacechildren');
xlabel('X (m)', 'FontSize', 14, 'interpreter', 'latex');
ylabel('Y (m)', 'FontSize', 14, 'interpreter', 'latex');
set(gca, 'FontSize', 14, 'TickLabelInterpreter', 'latex');
grid on;

% To save video (it shows an animation in real-time)
video = VideoWriter('followline');
video.FrameRate = 60;
video.Quality = 100;
open(video);
drawnow;
frame = getframe(gcf);
writeVideo(video, frame);
% Here we start from 2 since frame 1 was already drawn before
for i=2:length(videoTime)
    points = computeRobotPoints(x(i), y(i), psi(i));
    % Changing the points of the robot drawing
    set(handleChassis, 'XData', points.chassis.x,...
        'YData', points.chassis.y);
    set(handleTeamPattern, 'XData', points.teamPattern.x,...
        'YData', points.teamPattern.y);
    set(handleIdPattern, 'XData', points.idPattern.x,...
        'YData', points.idPattern.y);
    drawnow;
    pause(dt);
    frame = getframe(gcf);
    writeVideo(video, frame);
end
close(video);

end

function points = computeRobotPoints(x, y, psi)
% Computes the coordinates of the robot's points (color pattern and
% chassis) from the pose (x, y, psi). Uses the old pattern (2014) of
% ITAndroids VSS.

robotSize = 0.075; % official rules of Very Small Size (VSS)
patternSize = robotSize / 2.0;
% Creating the points using the non-rotated robot as referential
points.teamPattern.x = [-patternSize, 0, 0, -patternSize];
points.teamPattern.y = [patternSize, patternSize, 0, 0];
points.idPattern.x = [0, patternSize, patternSize, 0];
points.idPattern.y = [0, 0, -patternSize, -patternSize];
points.chassis.x = [-robotSize / 2, robotSize / 2, robotSize / 2, -robotSize / 2];
points.chassis.y = [robotSize / 2, robotSize / 2, -robotSize / 2, -robotSize / 2];

% Rotating the points to take the orientation into account
[points.teamPattern.x, points.teamPattern.y] =...
    rotate(points.teamPattern.x, points.teamPattern.y, psi);
[points.idPattern.x, points.idPattern.y] =...
    rotate(points.idPattern.x, points.idPattern.y, psi);
[points.chassis.x, points.chassis.y] = ...
    rotate(points.chassis.x, points.chassis.y, psi);

% Translating the points to take x and y into account
points.teamPattern.x = points.teamPattern.x + x;
points.teamPattern.y = points.teamPattern.y + y;
points.idPattern.x = points.idPattern.x + x;
points.idPattern.y = points.idPattern.y + y;
points.chassis.x = points.chassis.x + x;
points.chassis.y = points.chassis.y + y;

end

function [xRotated, yRotated] = rotate(x, y, psi)
% Rotates the coordinates x and y using the angle psi and returns the
% rotated coordinates as xRotated and yRotated, respectively.

xRotated = x * cos(psi) - y * sin(psi);
yRotated = x * sin(psi) + y * cos(psi);

end